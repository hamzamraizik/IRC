
/* just NOTES
Recieve() function:
recv() function returns the number of bytes received, or -1 if an error occurred.
if it used it will block the program until data is received.


HOW CONNECT() WORKS:
connect() function is used to connect to a server.

it takes 3 arguments:
1. the socket file descriptor
2. the server address
3. the size of the server address
Internal process:
1. check if the socket is already connected to a server
2. if not, try to connect to the server
3. if the connection is successful, return 0
4. if the connection is not successful, return -1

Step-By-Step:
1. Client sends SYN packet
2. Server responds with SYN-ACK
3. Client sends ACK (TCP 3-way handshake)
4. Connection enters ESTABLISHED state

send() Workflow:
Bot App->OS Kernel: send(fd, data)
OS Kernel->TCP Stack: Queue data
TCP Stack->IP Stack: Packetize
IP Stack->Network Interface: Transmit
Network Interface->Server: Ethernet/WiFi frames

Key Steps:
1. Your bot calls send(fd, ...)
2. OS checks fd is connected
3. Data is copied to kernel's send buffer
4. TCP stack:
5. Breaks data into packets
6. Adds TCP headers (source/dest ports, sequence numbers)
7. Handles retransmission if needed
8. IP stack adds IP headers (source/dest IPs)
9. Network driver sends frames over physical link

The fd contains all necessary connection info:
- Remote IP/port
- Local IP/port
- Socket state
- Send/recv buffers
- Error status
- Socket type (TCP, UDP, etc.)
it is internaly like:

struct socket {
        inet_sock {
          daddr = server_ip;  // From connect()
          dport = server_port;
          saddr = local_ip;   // Assigned by OS
          sport = local_port; // Random ephemeral port
      }
  }
OS uses this metadata to route packets correctly.

Replies should be modified:
in Channel::invite()
invite.cpp still have some replies to handle


//SIGPIPE
Default SIGPIPE Behavior:
If a client disconnects (closing their socket)
And you try to send data to that closed socket
The OS generates a SIGPIPE signal
By default, SIGPIPE immediately terminates the server process
Real-world Consequences:
One client disconnection could crash your entire IRC server
All other connected clients would be disconnected
The server would need to be manually restarted
Why This Happens:
This behavior dates back to early Unix pipe implementations
It was designed to terminate shell pipelines when one command exits
The same behavior was applied to sockets for consistency





